var sha256=require('sha256');
var crypto = require('crypto');
var cradle = require('cradle');

var conn=new(cradle.Connection)('https://couchdbserver', 443, {
      auth: { username: 'user', password: 'password' }
  });

var users = conn.database("js_ugr_users");
var cache = conn.database('js_ugr_usercache');

module.exports ={	
	users: {},
	fail: {},

	login: function(user,pass,ip){ 
		return function(callback){
			// initialize Date object
			var now=new Date();	

			// check if ip has failed login 10 times within the last minute
			if(module.exports.fail[ip]&&module.exports.fail[ip].times>=10){
				if((now.getTime()-module.exports.fail[ip].first)<=1*60*1000){
					callback({ok: false, error: "Login error" , reason: "Too many fails. Wait "+(1*60*1000-now.getTime()+module.exports.fail[ip].first)+" ms"});
				}else{
					delete module.exports.fail[ip];
				}
			}

			//only let user try to login if previous condition checks
			if(!module.exports.fail[ip]||module.exports.fail[ip].times<10){

				//check the passwords against the database
				module.exports.checkPass(user,pass)(function(response){
					if(!response.ok&&response.reason=="Wrong password"){
						
						//if the password is wrong, store the attempt
						if(module.exports.fail[ip]){
							module.exports.fail[ip].times=module.exports.fail[ip].times+1;
						}else{
							module.exports.fail[ip]={times: 1, first: now.getTime()};	
						}
					}

					//if the password checks, store the user name, the ip and the time of login in user vector
					if(response.ok){

						module.exports.users[user]={lastAction: now.getTime(), token: response.token};
						delete module.exports.fail[ip];
					}
					
					//Callback the response for the express response
					callback(response);			
				});	
			}
		}
	},

	checkPass: function(user,pass){
		return function(callback){
			var now=new Date();
			//get userdoc to check password
			users.get(user, function (err, doc) {
				if(err) { 
					if(err.error=="not_found"){
						callback({ok: false, error: "Login Error", reason: "User does not exist"});	
					}else{
						callback({ok: false, error: err.error, error: err.reason});
					}
				}else{
					// if the user is validated
					if(doc.validated){
						//and the password checks password sent is the same as in userdoc
						if(sha256(pass)==doc.pass){
							//save last login into user document in cache
							cache.get(user,function(err,doc){
								//send affirmative response
								crypto.randomBytes(16, function(ex, buf) {
									code = buf.toString('hex');
									if (!err) {
										var last=doc.lastLogin;
										doc.lastLogin=now;
										cache.save(user,doc);
										callback({ok: true, token: code, user: user,lastLogin: last});
									}else{
										callback({ok: true, token: code, user: user});
									}
	
								});								
							});
						}else{
							callback({ok: false, error: "Login Error", reason: "Wrong password"});
						}
					}else{//if user is not validated
						callback({ok: false, error: "Login Error", reason: "User not validated"});	
					}
				}
			});
		}
	},
	
	logout: function(user,ip,token){
		return function(callback){
			if(module.exports.users[user]){
				if(module.exports.users[user].token==token){
					delete module.exports.users[user];
					callback({ok: true});
				}else{
					callback({ok: false, error: "Logout error", reason: "Invalid Token"});
				}
			}else{
				callback({ok: false, error: "Logout error", reason: "User Not logged in"});
			}
		}
	},

	checkLogin: function(user,ip,token){ //this method is not asynchronous, it doesn't need a callback
		var now=new Date();
		if(user&&module.exports.users[user]){
			if((now.getTime()-module.exports.users[user].lastAction)<30*60*1000){ 
				if(module.exports.users[user].token==token){
				module.exports.users[user].lastAction=now.getTime();
				return {ok: true, user: user};
				}else{
					return {ok: false, error: "Not logged in", reason: "Token problem. Check your cookies"};
				}
			}else{
				return {ok: false, error: "Not logged in", reason: "Session expired"};
			}
		}
		return {ok: false};
	}

}

















